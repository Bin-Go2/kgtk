;;; -*- Mode: Lisp; Syntax: Common-Lisp; Package: STELLA; Base: 10. -*-

;;;;;;;;;;;;;;;;;;;;;;;;;;;;; BEGIN LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;                                                                            ;
; Copyright (C) 2020                                                         ;
; UNIVERSITY OF SOUTHERN CALIFORNIA, INFORMATION SCIENCES INSTITUTE          ;
; 4676 Admiralty Way, Marina Del Rey, California 90292, U.S.A.               ;
;                                                                            ;
; Permission is hereby granted, free of charge, to any person obtaining      ;
; a copy of this software and associated documentation files (the            ;
; "Software"), to deal in the Software without restriction, including        ;
; without limitation the rights to use, copy, modify, merge, publish,        ;
; distribute, sublicense, and/or sell copies of the Software, and to         ;
; permit persons to whom the Software is furnished to do so, subject to      ;
; the following conditions:                                                  ;
;                                                                            ;
; The above copyright notice and this permission notice shall be             ;
; included in all copies or substantial portions of the Software.            ;
;                                                                            ;
; THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,            ;
; EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF         ;
; MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND                      ;
; NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE     ;
; LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION     ;
; OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION      ;
; WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.            ;
;                                                                            ;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;; END LICENSE BLOCK ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


;;; Support for parsing and importing data from tab-separated KGTK files

(in-package "STELLA")

(in-module "KGTK")


;;; KGTK syntax:
;;; - derived from kojak/common/csv.ste
;;; - lines whose first non-whitespace character is `#' are treated as comments
;;; - blank, all whitespace lines are ignored.
;;; - TAB separates values
;;; - `|' separate multi-values; these are treated just like TAB in all aspects
;;;   except that they generate an `|' token so we can perform appropriate parsing actions.
;;; - leading whitespace is ignored (for now, we might have to tighten that up)
;;; - trailing whitespace to the next separator or end of line is significant
;;; - `\' can be used to escape significant TABs, `|'s or line endings
;;; - TAB followed by another TAB or end of line generate empty values

;;; Format extensions/clarifications compared to whats in the doc:
;;; - regular and lang-qualified strings do not need to escape quotes in their bodies,
;;;   but if they do as is currently mandated, it is harmless
;;; - dimensioned values should possibly have a mandatory space after the number for some
;;;   easier parsing by non-KGTK tools (otherwise 0x2 0b2 0o2 10e2 could all also be dimensioned)
;;; - we cannot fully parse ISO date/times, their validation needs to be done separately
;;;   (if at all)
;;; - we currently allow leading white space at the beginning of values, we should probably
;;;   turn that off
;;; - we do not fully follow the Python spec for numeric literals, we do not allow _ in
;;;   digits to group them, we only allow bxo based literals, and we do not distinguish
;;;   between regular and long integers
;;; - based numbers such as 0b10101 cannot be dimensioned, dimensioned numbers always use base 10
;;; - we currently don't enforce proper digit alphabets for based numbers
;;; - is the dash in 3-letter language codes as in 'deutsch'@de- legal?  it turns out those
;;;   are from subcodes such as de-ch, need to clarify whether those should be legal or not
;;; - we need to check that multi-values only occur in certain columns (or only in at most one)
;;; - backslashes in strings need to be escaped (e.g., latex formulas)


(defglobal *kgtk-tokenizer-table-definition* CONS
  (bquote
   (
    (:start
       ! "#" :comment
       ! #\space :start
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       * #\tab :separator
       :eof :eof
       * "\\" :value-escape
       * "\"" :string-body
       * "'"  :lq-string-body
       * "@"  :lat-long1-sign
       * "^"  :date-time0
       * "-+" :number-sign
       * "."  :number-fraction0
       * "!"  :other-literal0
       * "123456789" :number
       * "0" (:number-base-x0 :number)
       * :otherwise :value)

      (:comment
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :comment)

      (:end-of-line-cr
       #\linefeed :end-of-line
       ! "#" :comment
       ! #\space :start
       * #\tab :separator
       :eof :eof
       * "\\" :value-escape
       * "\"" :string-body
       * "'"  :lq-string-body
       * "@"  :lat-long1-sign
       * "^"  :date-time0
       * "-+" :number-sign
       * "."  :number-fraction0
       * "!"  :other-literal0
       * "123456789" :number
       * "0" (:number-base-x0 :number)
       * :otherwise :value)

      (:end-of-line
       :include :start)

      (:separator
       ! #\space :separator
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       * #\tab :separator
       * "\\" :value-escape
       * "\"" :string-body
       * "'" :lq-string-body
       * "@" :lat-long1-sign
       * "^" :date-time0
       * "-+" :number-sign
       * "."  :number-fraction0
       * "!"  :other-literal0
       * "123456789" :number
       * "0" (:number-base-x0 :number)
       * :otherwise :value)

      (:multi-value
       :include :separator)

      ;;; symbols:
      (:value
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       "\\" :value-escape
       :otherwise :value)

      (:escaped-value
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       "\\" :value-escape
       :otherwise :escaped-value)

      (:value-escape
       :eof :error
       :otherwise :escaped-value)

      ;;; double-quoted strings:
      (:string-body
       "\\" :string-escape
       "\"" :string
       (#\tab #\|) :error
       (#\linefeed #\return) :eol-error
       :eof :error
       :otherwise :string-body)

      (:string
       "\\" :string-escape
       "\"" :string
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :string-body)

      (:string-escape
       :eof :error
       :otherwise :escaped-string-body)

      (:escaped-string-body
       "\\" :string-escape
       "\"" :escaped-string
       (#\tab #\|) :error
       (#\linefeed #\return) :eol-error
       :eof :error
       :otherwise :escaped-string-body)

      (:escaped-string
       "\\" :string-escape
       "\"" :escaped-string
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :escaped-string-body)

      ;; single-quoted language-qualified strings with 2 or 3-letter tag:
      (:lq-string-body
       "\\" :lq-string-escape
       "'"  :lq-string-close
       (#\tab #\|) :error
       (#\linefeed #\return) :eol-error
       :eof :error
       :otherwise :lq-string-body)

      (:lq-string-close
       "\\" :lq-string-escape
       "'"  :lq-string-close
       "@"  :lq-string0
       #\tab :error
       (#\linefeed #\return) :eol-error
       "|" :error
       :eof :error
       :otherwise :lq-string-body)

      (:lq-string0
       "abcdefghijklmnopqrstuvwxyz" :lq-string1
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:lq-string1
       "abcdefghijklmnopqrstuvwxyz" :lq-string
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:lq-string
       ;; lenient wrt sub-language tags:
       "-abcdefghijklmnopqrstuvwxyz" (:lq-string3 :lq-string)
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      (:lq-string3
       ;; lenient wrt sub-language tags:
       "-abcdefghijklmnopqrstuvwxyz" (:lq-string3 :lq-string)
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      (:lq-string-escape
       :eof :error
       :otherwise :escaped-lq-string-body)

      (:escaped-lq-string-body
       "\\" :lq-string-escape
       "'"  :escaped-lq-string-close
       (#\tab #\|) :error
       (#\linefeed #\return) :eol-error
       :eof :error
       :otherwise :escaped-lq-string-body)

      (:escaped-lq-string-close
       "\\" :lq-string-escape
       "'"  :escaped-lq-string-close
       "@"  :escaped-lq-string0
       #\tab :error
       (#\linefeed #\return) :eol-error
       "|" :error
       :eof :error
       :otherwise :escaped-lq-string-body)

      (:escaped-lq-string0
       "abcdefghijklmnopqrstuvwxyz" :escaped-lq-string1
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:escaped-lq-string1
       "abcdefghijklmnopqrstuvwxyz" :escaped-lq-string
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:escaped-lq-string
       ;; lenient wrt sub-language tags:
       "-abcdefghijklmnopqrstuvwxyz" (:escaped-lq-string3 :escaped-lq-string)
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      (:escaped-lq-string3
       ;; lenient wrt sub-language tags:
       "-abcdefghijklmnopqrstuvwxyz" (:escaped-lq-string3 :escaped-lq-string)
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      
      ;; lat/long: @+123.456/-234.789
      ;; FIXME: this isn't quite right wrt optional signs, but needs extra states:
      (:lat-long1-sign
       "+-0123456789" :lat-long1
       "." :lat-long1-fraction
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:lat-long1
       "0123456789" :lat-long1
       "." :lat-long1-fraction
       "/" :lat-long2-sign
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:lat-long1-fraction
       "0123456789" :lat-long1-fraction
       "/" :lat-long2-sign
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:lat-long2-sign
       "+-0123456789" (:lat-long2 :lat-long)
       "." :lat-long
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:lat-long2
       "0123456789" (:lat-long2 :lat-long)
       "." :lat-long
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      (:lat-long
       "0123456789" :lat-long
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      ;; date/time/durations according to ISO 8601 followed by optional precision;
      ;; this format is complex, so here we only enforce a basic character set and
      ;; a minimal length of 1:
      (:date-time0
       "0123456789" :date-time
       "ABCDEFGHIJKLMNOPQRSTUVWXYZ" :date-time
       "+-.,:/" :date-time
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:date-time
       "0123456789" :date-time
       "ABCDEFGHIJKLMNOPQRSTUVWXYZ" :date-time
       "+-.,:/" :date-time
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      ;; numbers and dimensioned values:
      (:number-sign
       "123456789" :number
       "0" (:number-base-x0 :number)
       "." :number-fraction0
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:number-base-x0
       "bBoOxX" :number-base-x1
       "0123456789" :number
       "." (:number-fraction :number)
       "eE" :number-exponent-or-si-unit
       "[" :number-tolerance0
       "Q" :quantity-pnode-or-si-unit
       "ACDFGHIJKLMNPRSTUVWYZ" :quantity-si-unit
       "acdfghijklmnpqrstuvwyz" :quantity-si-unit
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      ;; TO DO: we need to enforce base-specific digit alphabets:
      (:number-base-x1
       "0123456789aAbBcCdDeEfF" :number-base-x
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:number-base-x
       "0123456789aAbBcCdDeEfF" :number-base-x
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      (:number
       "0123456789" :number
       "." (:number-fraction :number)
       "eE" :number-exponent-or-si-unit
       "[" :number-tolerance0
       "Q" :quantity-pnode-or-si-unit
       "ABCDFGHIJKLMNOPRSTUVWXYZ" :quantity-si-unit
       "abcdfghijklmnopqrstuvwxyz" :quantity-si-unit
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      (:number-fraction0
       "0123456789" (:number-fraction :number)
       (#\linefeed #\return) :eol-error
       :otherwise :error)
      
      (:number-fraction
       "0123456789" (:number-fraction :number)
       "eE" :number-exponent-or-si-unit
       "[" :number-tolerance0
       "Q" :quantity-pnode-or-si-unit
       "ABCDFGHIJKLMNOPRSTUVWXYZ" :quantity-si-unit
       "abcdfghijklmnopqrstuvwxyz" :quantity-si-unit
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      (:number-exponent-or-si-unit
       "+-" :number-exponent1
       "0123456789" (:number-exponent :number)
       "ABCDEFGHIJKLMNOPQRSTUVWXYZ" :quantity-si-unit
       "abcdefghijklmnopqrstuvwxyz" :quantity-si-unit
       (#\linefeed #\return) :eol-error
       :otherwise :error)
      
      (:number-exponent1
       "0123456789" (:number-exponent :number)
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:number-exponent
       "0123456789" (:number-exponent :number)
       "[" :number-tolerance0
       "Q" :quantity-pnode-or-si-unit
       "ABCDEFGHIJKLMNOPRSTUVWXYZ" :quantity-si-unit
       "abcdefghijklmnopqrstuvwxyz" :quantity-si-unit
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      ;; we currently don't tokenize the tolerance interval, we just check for basic charset:
      (:number-tolerance0
       "0123456789" :number-tolerance1
       "+-.,eE" :number-tolerance1
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:number-tolerance1
       "0123456789" :number-tolerance1
       "+-.,eE" :number-tolerance1
       "]" :number-tolerance
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:number-tolerance
       "Q" :quantity-pnode-or-si-unit
       "ABCDEFGHIJKLMNOPRSTUVWXYZ" :quantity-si-unit
       "abcdefghijklmnopqrstuvwxyz" :quantity-si-unit
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      (:quantity-pnode-or-si-unit
       "0123456789" :quantity-pnode-unit
       "ABCDEFGHIJKLMNOPQRSTUVWXYZ" :quantity-si-unit
       "abcdefghijklmnopqrstuvwxyz" :quantity-si-unit
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      (:quantity-pnode-unit
       "0123456789" :quantity-pnode-unit
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      (:quantity-si-unit0
       "ABCDEFGHIJKLMNOPQRSTUVWXYZ" :quantity-si-unit
       "abcdefghijklmnopqrstuvwxyz" :quantity-si-unit
       (#\linefeed #\return) :eol-error
       :otherwise :error)

      ;; we only do minimal parsing of SI units, checking for charset mostly:
      (:quantity-si-unit
       "ABCDEFGHIJKLMNOPQRSTUVWXYZ" :quantity-si-unit
       "abcdefghijklmnopqrstuvwxyz" :quantity-si-unit
       "0123456789" :quantity-si-unit
       "./" :quantity-si-unit0
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :error)

      ;; other and typed literals: !P1..3W^timex3,  !1000^^dbpedia:USD
      (:other-literal0
       "\\" :other-literal-escape1
       "^" :error
       (#\tab #\|) :error
       (#\linefeed #\return) :eol-error
       :eof :error
       :otherwise :other-literal1)

      (:other-literal-escape1
       :eof :error
       :otherwise :other-literal1)

      (:other-literal1
       "\\" :other-literal-escape1
       "^" :other-literal-sep0
       (#\tab #\|) :error
       (#\linefeed #\return) :eol-error
       :eof :error
       :otherwise :other-literal1)

      (:other-literal-sep0
       "^" :typed-literal0
       (#\tab #\|) :error
       (#\linefeed #\return) :eol-error
       :eof :error
       :otherwise :other-literal)

      (:other-literal
       "\\" :other-literal-escape
       "^" :error
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :other-literal)

      (:other-literal-escape
       :eof :error
       :otherwise :other-literal)

      (:typed-literal0
       "\\" :typed-literal-escape
       "^" :error
       (#\tab #\|) :error
       (#\linefeed #\return) :eol-error
       :eof :error
       :otherwise :typed-literal)

      (:typed-literal
       "\\" :typed-literal-escape
       "^" :error
       * #\tab :separator
       * "|" :multi-value
       * #\linefeed :end-of-line
       * #\return (:end-of-line-cr :end-of-line)
       :eof :eof
       :otherwise :typed-literal)

      (:typed-literal-escape
       :eof :error
       :otherwise :typed-literal)

      ;; we need to capture if an error happened right when we consumed
      ;; an EOL char so we can keep the line count accurate in that case:
      (:eol-error
       :include :start)

      (:error
       :include :start))))


(defglobal *kgtk-tokenizer-table* TOKENIZER-TABLE
           (parse-tokenizer-definition *kgtk-tokenizer-table-definition*))

(defun (tokenize-kgtk-string CONS) ((text STRING))
  ;; Test driver to test out the KGTK tokenizer table.
  (let ((result NIL))
    (foreach token in (new STREAM-TOKENIZER
                           :stream (new STRING-INPUT-STREAM :the-string text)
                           :table *kgtk-tokenizer-table*)
        collect (cons-list (content token) (type token)) into result)
    (return result)))


;; TO DO:
;; - the current iterator version below supports error checking and writing out validated output
;;   to be passed to follow-on operations (e.g. sort)
;; - we should create a variant that doesn't write out validated output for some extra speed
;; - we should also create a more general reader variant that generates typed, unescaped
;;   values parsed into fields; this might require a parallel output array with offset/type info

(defclass KGTK-VALIDATION-ITERATOR (ABSTRACT-ITERATOR)
  :documentation "Tokenizing iterator that iterates over KGTK files and checks the syntax of
fields and consistency of columns and outputs error messages and validated output.  Generated
output omits all commented and blank lines.  No deeper semantic checks are performed such as
validity of times, language tags, locations, etc."
  :parameters ((any-value :type STRING-BUFFER))
  :slots ((input-stream :type INPUT-STREAM :initially NULL)
          (log-stream :type OUTPUT-STREAM :initially NULL)
          (invalid-stream :type OUTPUT-STREAM :initially NULL)
          (suppress-header? :type BOOLEAN :initially FALSE
            :documentation "If true, the header row will be suppresed in any output.")
          (invalid-value-action :type KEYWORD :initially :PASS)
          (error-limit :type INTEGER :initially 1000)
          (chunk-size :type INTEGER :initially 1000
            :documentation "Number of rows to read at a time.")
          (field-separator :type CHARACTER :initially #\tab)
          (row-separator :type CHARACTER :initially #\linefeed)
          ;; FIXME: this type seems to run us into memory corruption problems, e.g., when
          ;; we call `kpi.testKgtkValidationIterator2' and friends repeatedly, investigate...
          ;(header-columns :type (VECTOR-SEQUENCE OF STRING-WRAPPER)
          ;                :initially (new VECTOR-SEQUENCE :array-size 16))
          ;; use LIST for now:
          (header-columns :type (LIST OF STRING-WRAPPER) :initially (new LIST))
          (line-number :type INTEGER :initially 0)
          (buffer :renames value :type STRING-BUFFER :initially (new STRING-BUFFER))
          ))

(defglobal *max-number-of-columns* INTEGER (expt 2 16)
  :documentation "Maximum number of columns allowed to guards against run-aways."
  :public? TRUE)

(defmethod (number-of-columns INTEGER) ((self KGTK-VALIDATION-ITERATOR))
  :documentation "Number of columns as determined by the header line.  If the header has not been parsed
yet, this will be 0."
  :public? TRUE
  (return (length (header-columns self))))

(defun (allocate-kgtk-validation-iterator KGTK-VALIDATION-ITERATOR) ((file STRING) (logFile STRING) (invalidFile STRING))
  :documentation "Allocate a KGTK iterator given relevant input and output files.  If files are left unspecified,
relevant standard input and error streams will be used."
  :public? TRUE
  ;; TO DO: this will go away or be generalized once we can wrap Python streams
  (let ((iter (new KGTK-VALIDATION-ITERATOR :input-stream STANDARD-INPUT :log-stream STANDARD-ERROR)))
    (if (defined? file)
        (setf (input-stream iter) (new FILE-INPUT-STREAM :filename file))
      (setf (input-stream iter) STANDARD-INPUT))
    ;; ensure block buffering for efficiency as well as to avoid a STELLA bug in `read-into-tokenizer-buffer':
    (setf (buffering-scheme (input-stream iter)) :BLOCK)
    (if (defined? logFile)
        (setf (log-stream iter) (new FILE-OUTPUT-STREAM :filename logFile))
      (setf (log-stream iter) STANDARD-ERROR))
    (when (defined? invalidFile)
      (setf (invalid-stream iter) (new FILE-OUTPUT-STREAM :filename invalidFile)))
    (return iter)))

(defmethod process-header ((self KGTK-VALIDATION-ITERATOR))
  :documentation "Finish processing header information assuming the end of the first content line
has just been reached.  Raises errors in some situations, e.g., if this isn't the first line of
the stream, or if there were any syntax problems in the header elements."
  :public? TRUE
  (when (> (line-number self) 0)
    ;; from this we cannot continue:
    (signal-read-error "KGTK header is not in first line but line: " (1+ (line-number self))))
  (let ((headerLine (the-string (buffer self)))
        (columns (split-string headerLine #\tab))
        (header (header-columns self)))
    (foreach col in columns
        do (insert header col))
    (reverse header) ;; assuming LIST or CONS
    (cond ((suppress-header? self)
           (clear (buffer self)))
          (otherwise
           (output-separators self (row-separator self) 1)
           (when (defined? (invalid-stream self))
             ;; by outputting the header here, we will get a header-only file if there are no errors:
             (print-stream (invalid-stream self) headerLine (row-separator self)))))))

(defmethod output-separators ((self KGTK-VALIDATION-ITERATOR) (sep CHARACTER) (n INTEGER))
  :documentation "Output `n' `sep'arators to `self's buffer."
  :public? TRUE
  (when (>= n 1)
    (let ((buffer (buffer self))
          (buf (buffer buffer))
          (fp (fill-pointer buffer)))
      (when (< (- (buffer-size buffer) fp) n)
        (setq buf (ensure-free-space buffer n)))
      (setq n (+ fp n))
      (while (< fp n)
        (setf (nth buf fp) sep)
        (++ fp))
      (setf (fill-pointer buffer) fp))))

(defmethod close ((self KGTK-VALIDATION-ITERATOR))
  :documentation "Close any of `self's open streams and set them to NULL to signal
that the iterator is closed."
  :public? TRUE
  (when (and (defined? (input-stream self))
             (isa? (input-stream self) @FILE-INPUT-STREAM))
    (close-stream (input-stream self))
    (setf (input-stream self) NULL))
  (when (and (defined? (log-stream self))
             (isa? (log-stream self) @FILE-OUTPUT-STREAM))
    (close-stream (log-stream self))
    (setf (log-stream self) NULL))
  (when (and (defined? (invalid-stream self))
             (isa? (invalid-stream self) @FILE-OUTPUT-STREAM))
    (close-stream (invalid-stream self))
    (setf (invalid-stream self) NULL)))

(defmethod (next? BOOLEAN) ((self KGTK-VALIDATION-ITERATOR))
  :documentation "Validate the next `chunk-size' content lines of `self's input stream and
write the validated result to `buffer'.  Return TRUE if at least one content line could be
read before EOF was reached."
  :public? TRUE
  (when (null? (input-stream self))
    (return FALSE))
  (let ((buffer (value self))
        (chunkSize (chunk-size self))
        (lineNumber (line-number self))
        (lineStart 0)
        (invalidAction (invalid-value-action self))
        (invalidLine? FALSE)
        (nColumns (number-of-columns self))
        (nRows 0)
        (column 0)
        (state :START)
        (priorState :SEPARATOR)
        (fieldSep (field-separator self))
        (rowSep (row-separator self))
        (queuedSeps 0))
    (clear buffer)
    (with-tokenizer *kgtk-tokenizer-table* (input-stream self)
      (unwind-protect
        (while (< nRows chunkSize)
          (get-next-token FALSE)
          (when (end-of-tokens?)
            (close self)
            (break))
          (setq state (get-token-type))
          (cond ((eql? state :SEPARATOR)
                 (++ queuedSeps))
                ((> queuedSeps 0)
                 (output-separators self fieldSep queuedSeps)
                 (++ column (1- queuedSeps))
                 (when (eql? state :END-OF-LINE)
                   ;; ensure we are counting the last empty column:
                   (++ column))
                 (setq queuedSeps 0)))
          (when (>= column *max-number-of-columns*)
            (signal-read-error "Line " (1+ lineNumber) ": run-away line, max number of columns exceeded"))
          (case state
            (:SEPARATOR NULL)
            (:END-OF-LINE
             (cond ((and (not (= column nColumns))
                         (> nColumns 0)
                         (> column 0))
                    ;; we handle this first in case we have an invalid line with mismatched columns which
                    ;; can also happen due to some invalid tokens (but maybe those are tokenizer bugs?):
                    (output-separators self rowSep 1)
                    (setf (line-number self) lineNumber)
                    (handle-column-mismatch self lineStart column))
                   (invalidLine?
                    ;; if this is the header line, we will terminate:
                    (output-separators self rowSep 1)
                    (handle-invalid-line self lineStart)
                    (setq invalidLine? FALSE))
                   ((<= nColumns 0)
                    (setf (line-number self) lineNumber)
                    (process-header self)
                    (setq nColumns (number-of-columns self)))
                   ((eq? rowSep fieldSep)
                    (++ queuedSeps))
                   (otherwise
                    (output-separators self rowSep 1)))
             (++ lineNumber)
             (when (> column 0)
               (++ nRows))
             (setq column 0)
             (setq lineStart (fill-pointer buffer)))
            ((:ESCAPED-VALUE :ESCAPED-STRING :ESCAPED-LQ-STRING)
             ;; not unescaping (yet) in this scheme:
             (copy-token-text buffer)
             (unless (eql? priorState :MULTI-VALUE)
               (++ column)))
            (:MULTI-VALUE
             ;; TO DO: for now we keep multi-values as a single token; if we decide to split them
             ;; up here we need to output extra rows to keep the number of columns constant:
             (copy-token-text buffer))
            ((:ERROR :EOL-ERROR)
             (save-tokenizer-stream-state)
             (setf (line-number self) lineNumber)
             (let ((badToken (handle-error self (get-token-type) (get-token-text) column)))
               (cond ((eql? invalidAction :EXCLUDE)
                      (setq badToken ""))
                     (otherwise
                      ;; currently we can only save invalid lines for :PASS and :EXCLUDE-LINE:
                      (setq invalidLine? TRUE)))
               (append-string buffer badToken))
             (when (= (-- (error-limit self)) 0)
               (signal-read-error "Maximum number of errors exceeded"))
             (restore-tokenizer-stream-state)
             (cond ((eql? state :EOL-ERROR)
                    (if (eq? rowSep fieldSep)
                        (++ queuedSeps)
                      (output-separators self rowSep 1))
                    (when invalidLine?
                      (handle-invalid-line self lineStart)
                      (setq invalidLine? FALSE))
                    (++ lineNumber)
                    (++ nRows)
                    (setq column 0)
                    (setq lineStart (fill-pointer buffer)))
                   ((not (eql? priorState :MULTI-VALUE))
                    (++ column)))
             (when (null? (input-stream self))
               (break)))
            (otherwise
             ;; a "normal" token:
             (copy-token-text buffer)
             (unless (eql? priorState :MULTI-VALUE)
               (++ column))))
          (setq priorState state))
        (save-tokenizer-stream-state)))
    (output-separators self fieldSep queuedSeps)
    (setf (line-number self) lineNumber)
    (return (> nRows 0))))

;;; Not used yet:
(defun (unescape-kgtk-token STRING) ((token STRING))
  :documentation "Unescape an escaped KGTK value `token'."
  :public? TRUE :globally-inline? TRUE
  ;; FOR NOW: this doesn't do quite the right thing with character escapes:
  (return (unescape-token-string token #\\ FALSE)))
          
(defmethod (handle-error STRING) ((self KGTK-VALIDATION-ITERATOR)
                                  (tokenType KEYWORD) (tokenText STRING)
                                  (column INTEGER))
  :documentation "Print an error message to the log stream, advance the input to a safe state
to continue from and return the full erroneous token or text that was skipped.  Any additional
linenumber/column handling has to be done by the caller."
  (let ((inp (input-stream self))
        (linenum (1+ (line-number self)))
        (tokenLength (length tokenText))
        (char (nth tokenText (1- tokenLength))))
    ;; since empty values are legal, we should never have an empty error token here - but just in case:
    (safety 1 (> tokenLength 0) "INTERNAL ERROR: handle-error: unexpected empty token")
    (print-stream (log-stream self) "Line " linenum "[" (1+ column) "]: Bad syntax: " tokenText EOL)
    (cond ((eql? char #\tab)
           (return (subsequence tokenText 0 (1- tokenLength))))
          ((eql? tokenType :EOL-ERROR)
           (when (eql? char #\return)
             (setq char (read-character inp))
             (unless (eql? char #\linefeed)
               (unread-character char inp)))
           (return (subsequence tokenText 0 (1- tokenLength))))
          (otherwise
           (let ((buffer (new STRING-OUTPUT-STREAM))
                 (maxSkip 100000)
                 (eof? FALSE))
             (print-stream buffer tokenText)
             (while (> maxSkip 0)
               (-- maxSkip)
               (mv-setq (char eof?) (read-character inp))
               (when eof?
                 (close self)
                 (return (the-string buffer)))
               (case char
                 ((#\tab #\linefeed #\return)
                  (unread-character char inp)
                  (return (the-string buffer)))
                 (otherwise
                  (print-stream buffer char))))
             (signal-read-error "Line " linenum ": Runaway error token"))))))

(defmethod handle-invalid-line ((self KGTK-VALIDATION-ITERATOR) (lineStart INTEGER))
  :documentation "Complete the processing of a line that contains one or more invalid tokens.
Writes the line to the invalid line stream if it exists, clears the line buffer if necessary
to exclude the invalid line, and raises an error in case this was the header line."
  (let ((buffer (buffer self))
        (invalidStream (invalid-stream self)))
    (safety 1 (<= lineStart (length buffer))
            "INTERNAL ERROR: handle-invalid-line: lineStart > bufferLength: " lineStart " " (length buffer))
    (when (defined? invalidStream)
      (print-stream invalidStream (subsequence buffer lineStart (length buffer))))
    (when (eql? (invalid-value-action self) :EXCLUDE-LINE)
      (setf (length buffer) lineStart))
    (when (<= (number-of-columns self) 0)
      (signal-read-error "Line 1: invalid header line"))))

(defmethod handle-column-mismatch ((self KGTK-VALIDATION-ITERATOR) (lineStart INTEGER) (column INTEGER))
  :documentation "Complete the processing of a line that has an incorrect number of columns.
Writes the line to the invalid line stream if it exists, clears the line buffer if necessary
to exclude the invalid line, and adds blank columns or removes extraneous columns if the
invalid value action is different from :EXCLUDE-LINE."
  (let ((buffer (buffer self))
        (invalidStream (invalid-stream self))
        (nColumns (number-of-columns self))
        (linenum (1+ (line-number self)))
        (fieldSep (field-separator self))
        (rowSep (row-separator self)))
    (safety 1 (<= lineStart (length buffer))
            "INTERNAL ERROR: handle-column-mismatch: lineStart > bufferLength: " lineStart " " (length buffer))
    (print-stream (log-stream self) "Line " linenum ": Too " (choose (< column nColumns) "few" "many")
                  " columns: " column EOL)
    (when (defined? invalidStream)
      (print-stream invalidStream (subsequence buffer lineStart (length buffer))))
    (cond ((eql? (invalid-value-action self) :EXCLUDE-LINE)
           (setf (length buffer) lineStart))
          ((< column nColumns)
           ;; output additional empty fields, delete row separator first:
           (-- (fill-pointer buffer))
           (output-separators self fieldSep (- nColumns column))
           (output-separators self rowSep 1))
          (otherwise
           ;; remove extraneous fields:
           (let ((buf (buffer buffer))
                 (cursor (fill-pointer buffer)))
             (while (>= cursor 0)
               (when (eql? (nth buf cursor) fieldSep)
                 (-- column))
               (when (= column nColumns)
                 (setf (length buffer) cursor)
                 (break))
               (-- cursor))
             (output-separators self rowSep 1))))))


;;; Callback streams:

(defconstant CALLBACK-STREAM-PUTBACK INTEGER 8)

(defclass CALLBACK-INPUT-STREAM (INPUT-STREAM)
  :documentation "Input stream class that uses a Python callback to read chunks of data.
`fill-read-buffer' in conjunction with `python-reader' are doing the work to fetch data
and supplying it to the stream buffer of the underlying C++ stream object."
  :slots ((python-stream :type PYTHON-OBJECT-POINTER)
          (python-reader :type FUNCTION-CODE)
          (buffer-size :type INTEGER :initially 4096)
          (buffer :type MUTABLE-STRING)
          ;; FIXME: `read-into-tokenizer-buffer' doesn't work right with :LINE buffering
          (buffering-scheme :initially :BLOCK)
          (debug-stream :type INPUT-STREAM))
  :initializer initialize-object)


;;; The C++ input stream class below uses a customized stream buffer object which
;;; modifies the virtual `underflow()' method which gets called whenever the current buffer
;;; is empty.  The trick here was to provide a modified stream buffer class, since it has
;;; virtual methods that can be overridden.  The stream classes themselves cannot be
;;; directly specialized in this way, since they do not provide any virtual methods.

(verbatim :cpp
  "class NativeCallbackStreambuffer: public std::streambuf {
public:
  CallbackInputStream* callbackStream = NULL;
  char* buffer_ = NULL;
  int bufsize_  = -1;
  int putback_ = 0;

  void checkBounds(const char* loc) {
    // debugging utility
    char* start = buffer_;
    char* end = buffer_ + putback_ + bufsize_;
    if ( eback() < start || eback() > end || gptr() < start || gptr() > end || egptr() < start || egptr() > end ) {
      std::cerr << \">>> checkBounds: buffer bounds violation at: \" << loc << std::endl;
      throw *newReadException(\"checkBounds: buffer bounds violation\");
    }
  }

  NativeCallbackStreambuffer(CallbackInputStream* cbstream, char* buffer, int bufsize, int pb=0) : std::streambuf() {
    callbackStream = cbstream;
    bufsize_ = bufsize;
    putback_ = pb;
    buffer_  = buffer;

    char* bufend = buffer_ + putback_ + bufsize_;
    setg(bufend, bufend, bufend);
    //std::cerr << \">>> NativeCallbackStreambuffer: \" << putback_ + bufsize_ << std::endl;
  }

  virtual std::streambuf::int_type underflow() {
    //std::cerr << \">>> underflow: \"<< std::endl;
    if ( gptr() < egptr() ) {
      //checkBounds(\"underflow1\");
      return traits_type::to_int_type(*gptr());
    }
    else {
      // read the next chunk of data using fill-read-buffer, first save any putback:
      for (int i = 0; i < putback_; i++ ) {
        buffer_[i] = *(gptr() - putback_ + i);
      }
      int clen = callbackStream->fillReadBuffer(buffer_ + putback_);
      if ( clen <= 0 ) {
        //std::cerr << \">>> underflow: EOF\"<< std::endl;
        return traits_type::eof();
      }
    // crucial call that points streambuf to the location of the newly buffered data:
    setg(buffer_, buffer_ + putback_, buffer_ + putback_ + clen);
    //checkBounds(\"underflow2\");
    //return traits_type::to_int_type(*gptr());
    return traits_type::to_int_type(*(buffer_ + putback_));
    }
  }
};

class NativeCallbackStream: public std::istream {
public:
  NativeCallbackStream(CallbackInputStream* cbstream, char* buffer, int bufsize, int pb=0) : std::istream() {
    // set the read buffer of this stream to our customized version:
    rdbuf(new (GC) NativeCallbackStreambuffer(cbstream, buffer, bufsize, pb));
  }
};

" :otherwise NULL)


(defmethod initialize-object ((self CALLBACK-INPUT-STREAM))
  :documentation "Initialize the native stream of 'self' with a new
NativeCallbackInputStream and initialize or resize the buffer."
  :public? TRUE
  (let ((bsize (buffer-size self))
        (putback CALLBACK-STREAM-PUTBACK)
        (buffer (make-mutable-string (+ putback bsize) #\space)))
    ;; IMPORTANT: link the buffer here to prevent premature GC - this took us a while to track down:
    (setf (buffer self) buffer)
    (setf (native-stream self)
      (verbatim :cpp "new (GC) NativeCallbackStream(self, buffer, bsize, putback)"
                :otherwise NULL))))

(defmethod (fill-read-buffer INTEGER) ((self CALLBACK-INPUT-STREAM) (buffer MUTABLE-STRING))
  :documentation "Read the next chunk of data into `buffer' and return how many bytes were read.
Return -1 when EOF is encountered.  Assumes `buffer' is of at least (buffer-size self).  We pass
in `buffer' instead of using it directly from `self' to allow initial putback offsets.  This calls
a `python-reader' callback on the Python side that reads data and copies it into `buffer'."
  :public? TRUE
  (let ((clen -1))
    (cond ((defined? (debug-stream self))
           (if-output-language :cpp
               (setq clen (byte-array-read-sequence (cast buffer TOKENIZER-BYTE-ARRAY) (debug-stream self) 0 (buffer-size self)))
               NULL))
          (otherwise
           (setq clen (funcall (python-reader self) (python-stream self) buffer (buffer-size self)))))
    (cond ((<= clen 0)
           (return -1)) ;; EOF
          (otherwise
           (return clen)))))


;;; Testing:

(defmethod check-integrity ((self KGTK-VALIDATION-ITERATOR) (where STRING))
  ;; Debugging utility to track down memory corruption.
  (let ((input (input-stream self))
        (buffer (buffer self))
        (len (length buffer))
        (size (buffer-size buffer))
        (buf (buffer buffer)))
    (typecase input
      (CALLBACK-INPUT-STREAM
       (when (and (defined? (python-stream input))
                  (not (long-integer? (python-stream input))))
         (print "INTERNAL ERROR: python stream pointer corrupted" EOL)
         (break-program "break"))
       (let ((natstream (native-stream input))
             (rdbufsize (+ (buffer-size input) CALLBACK-STREAM-PUTBACK))
             (rdbuf MUTABLE-STRING
                    (verbatim :cpp "((NativeCallbackStreambuffer*)((NativeCallbackStream*)natstream)->rdbuf())->buffer_"
                              :otherwise NULL)))
         (when (< (verbatim :cpp "(int)strnlen(rdbuf, rdbufsize)" :otherwise rdbufsize) rdbufsize)
           (print "INTERNAL ERROR: read buffer corrupted" EOL)
           (print "  at:   " where EOL)
           (print "  line: " (line-number self) EOL)
           (print "  off:  " (verbatim :cpp "strnlen(rdbuf, rdbufsize)" :otherwise rdbufsize) EOL)
           (break-program "break"))))
      (otherwise NULL))
    (when (< (verbatim :cpp "(int)strnlen(buf, size)" :otherwise size) len)
      (print "INTERNAL ERROR: string buffer corrupted" EOL)
      (print "  at:   " where EOL)
      (print "  line: " (line-number self) EOL)
      (break-program "break"))))

(defun (test-kgtk-validation-iterator INTEGER) ((file STRING) (logFile STRING))
  :documentation "Test driver."
  :public? TRUE :command? TRUE
  (let ((iter (allocate-kgtk-validation-iterator file logFile NULL)))
    (while (next? iter)
      NULL)
    (return (line-number iter))))

(defun (test-kgtk-validation-iterator2 INTEGER) ((file STRING) (logFile STRING))
  :documentation "Test driver."
  :public? TRUE :command? TRUE
  (let ((iter (allocate-kgtk-validation-iterator file logFile NULL))
        (frame NIL))
    (ignore frame)
    (setf (row-separator iter) #\tab)
    (while (next? iter)
      (setq frame (split-string (the-string (value iter)) #\tab)))
    (return (line-number iter))))

(defun test-kgtk-validation-iterator3 ((file STRING) (logFile STRING) (nLines INTEGER))
  :documentation "Test driver."
  :public? TRUE :command? TRUE
  (let ((iter (allocate-kgtk-validation-iterator file logFile NULL))
        (frame NIL)
        (item "")
        (cursor 0))
    (setf (row-separator iter) #\tab)
    (foreach batch in iter
        do (setq frame (split-string (the-string batch) #\tab))
           (while (non-empty? frame)
             (setq item (unwrap-string (first frame)))
             (when (blank-string? item)
               (setq item "."))
             (print item "	")
             (++ cursor)
             (setq frame (rest frame))
             (when (= (mod cursor (number-of-columns iter)) 0)
               (print EOL)
               (-- nLines))
             (when (<= nLines 0)
               (close iter)
               (return))))))

(defun (test-kgtk-validation-iterator4 INTEGER) ((file STRING) (logFile STRING) (invalidFile STRING))
  :documentation "Test driver."
  :public? TRUE :command? TRUE
  (let ((iter (allocate-kgtk-validation-iterator file logFile invalidFile))
        ;(bufsize 4096)
        (bufsize 1048576)
        (count LONG-INTEGER 0))
    (setf (error-limit iter) 0)
    (setf (invalid-value-action iter) :EXCLUDE-LINE)
    (setf (input-stream iter)
      (new CALLBACK-INPUT-STREAM
           :debug-stream (input-stream iter)
           :buffer-size bufsize))
    (initialize-object (cast (input-stream iter) CALLBACK-INPUT-STREAM))
    (while (next? iter)
      (++ count (length (the-string (value iter)))))
    (print (line-number iter) " " count EOL)
    (return (line-number iter))))

(defun (test-kgtk-validation-iterator5 INTEGER) ((file STRING) (logFile STRING) (invalidFile STRING))
  :documentation "Test driver.  Just like #4 but without the callback stream so we can test in Java."
  :public? TRUE :command? TRUE
  (let ((iter (allocate-kgtk-validation-iterator file logFile invalidFile))
        (count LONG-INTEGER 0))
    (setf (error-limit iter) 0)
    (setf (invalid-value-action iter) :EXCLUDE-LINE)
    (while (next? iter)
      (++ count (length (the-string (value iter)))))
    (print (line-number iter) " " count EOL)
    (return (line-number iter))))
